#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_15__   TYPE_3__ ;
typedef  struct TYPE_14__   TYPE_2__ ;
typedef  struct TYPE_13__   TYPE_1__ ;

/* Type definitions */
typedef  scalar_t__ user_addr_t ;
typedef  scalar_t__ uint32_t ;
struct uthread {int uu_siglist; int uu_flag; int uu_oldmask; int uu_sigmask; int /*<<< orphan*/  uu_exit_reason; } ;
struct sigacts {scalar_t__* ps_sigact; int ps_sig; int* ps_catchmask; int ps_signodefer; int ps_sigreset; int ps_siginfo; scalar_t__ ps_code; } ;
typedef  TYPE_3__* proc_t ;
typedef  int /*<<< orphan*/  os_reason_t ;
struct TYPE_15__ {int p_sigignore; TYPE_2__* p_stats; int /*<<< orphan*/  p_pid; struct sigacts* p_sigacts; int /*<<< orphan*/  p_acflag; } ;
struct TYPE_13__ {int /*<<< orphan*/  ru_nsignals; } ;
struct TYPE_14__ {TYPE_1__ p_ru; } ;

/* Variables and functions */
 int /*<<< orphan*/  AXSIG ; 
 int BSDDBG_CODE (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  BSD_PROC_FRCEXIT ; 
 int /*<<< orphan*/  DBG_BSD_PROC ; 
 int DBG_FUNC_NONE ; 
 int /*<<< orphan*/  KERNEL_DEBUG_CONSTANT (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  OSIncrementAtomicLong (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  OS_REASON_NULL ; 
 int SA_CORE ; 
 int SA_IGNORE ; 
 int SIGCONT ; 
 int SIGILL ; 
 int SIGTRAP ; 
 scalar_t__ SIG_DFL ; 
 int /*<<< orphan*/  TRUE ; 
 int UT_SAS_OLDMASK ; 
 int /*<<< orphan*/  W_EXITCODE (int /*<<< orphan*/ ,int) ; 
 TYPE_3__* current_proc () ; 
 int /*<<< orphan*/  current_thread () ; 
 int /*<<< orphan*/  exit_with_reason (TYPE_3__*,int /*<<< orphan*/ ,int*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 scalar_t__ get_bsdthread_info (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  os_reason_ref (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  proc_lock (TYPE_3__*) ; 
 int /*<<< orphan*/  proc_signalend (TYPE_3__*,int) ; 
 int /*<<< orphan*/  proc_signalstart (TYPE_3__*,int) ; 
 int /*<<< orphan*/  proc_unlock (TYPE_3__*) ; 
 int /*<<< orphan*/  sendsig (TYPE_3__*,scalar_t__,int,int,scalar_t__) ; 
 int /*<<< orphan*/  sig_lock_to_exit (TYPE_3__*) ; 
 scalar_t__ sig_try_locked (TYPE_3__*) ; 
 int sigmask (int) ; 
 int* sigprop ; 

void
postsig_locked(int signum)
{
	proc_t p = current_proc();
	struct sigacts *ps = p->p_sigacts;
	user_addr_t catcher;
	uint32_t code;
	int mask, returnmask;
	struct uthread * ut;
	os_reason_t ut_exit_reason = OS_REASON_NULL;

#if DIAGNOSTIC
	if (signum == 0)
		panic("postsig");
	/*
	 *	This must be called on master cpu
	 */
	if (cpu_number() != master_cpu)
		panic("psig not on master");
#endif

	/*
	 * Try to grab the signal lock.
	 */
	if (sig_try_locked(p) <= 0) {
		return;
	}

	proc_signalstart(p, 1);

	ut = (struct uthread *)get_bsdthread_info(current_thread());
	mask = sigmask(signum);
	ut->uu_siglist &= ~mask;
	catcher = ps->ps_sigact[signum];
	if (catcher == SIG_DFL) {
		/*
		 * Default catcher, where the default is to kill
		 * the process.  (Other cases were ignored above.)
		 */
		sig_lock_to_exit(p);

		/*
		 * exit_with_reason() below will consume a reference to the thread's exit reason, so we take another
		 * reference so the thread still has one even after we call exit_with_reason(). The thread's reference will
		 * ultimately be destroyed in uthread_cleanup().
		 */
		ut_exit_reason = ut->uu_exit_reason;
		os_reason_ref(ut_exit_reason);

		p->p_acflag |= AXSIG;
		if (sigprop[signum] & SA_CORE) {
			p->p_sigacts->ps_sig = signum;
			proc_signalend(p, 1);
			proc_unlock(p);
#if CONFIG_COREDUMP
			if (coredump(p, 0, 0) == 0)
				signum |= WCOREFLAG;
#endif
		} else  {
			proc_signalend(p, 1);
			proc_unlock(p);
		}
		
#if CONFIG_DTRACE
		bzero((caddr_t)&(ut->t_dtrace_siginfo), sizeof(ut->t_dtrace_siginfo));

		ut->t_dtrace_siginfo.si_signo = signum;
		ut->t_dtrace_siginfo.si_pid = p->si_pid;
		ut->t_dtrace_siginfo.si_uid = p->si_uid;
		ut->t_dtrace_siginfo.si_status = WEXITSTATUS(p->si_status);

		/* Fire DTrace proc:::fault probe when signal is generated by hardware. */
		switch (signum) {
		case SIGILL: case SIGBUS: case SIGSEGV: case SIGFPE: case SIGTRAP:
			DTRACE_PROC2(fault, int, (int)(ut->uu_code), siginfo_t *, &(ut->t_dtrace_siginfo));
			break;
		default:
			break;
		}
		

		DTRACE_PROC3(signal__handle, int, signum, siginfo_t *, &(ut->t_dtrace_siginfo),
					void (*)(void), SIG_DFL);
#endif

		KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_PROC, BSD_PROC_FRCEXIT) | DBG_FUNC_NONE,
					      p->p_pid, W_EXITCODE(0, signum), 3, 0, 0);

		exit_with_reason(p, W_EXITCODE(0, signum), (int *)NULL, TRUE, TRUE, 0, ut_exit_reason);

		proc_lock(p);
		return;
	} else {
		/*
		 * If we get here, the signal must be caught.
		 */
#if DIAGNOSTIC
		if (catcher == SIG_IGN || (ut->uu_sigmask & mask))
			log(LOG_WARNING,
				"postsig: processing masked or ignored signal\n");
#endif

		/*
		 * Set the new mask value and also defer further
		 * occurences of this signal.
		 *
		 * Special case: user has done a sigpause.  Here the
		 * current mask is not of interest, but rather the
		 * mask from before the sigpause is what we want
		 * restored after the signal processing is completed.
		 */
		if (ut->uu_flag & UT_SAS_OLDMASK) {
			returnmask = ut->uu_oldmask;
			ut->uu_flag &= ~UT_SAS_OLDMASK;
			ut->uu_oldmask = 0;
		} else
			returnmask = ut->uu_sigmask;
		ut->uu_sigmask |= ps->ps_catchmask[signum];
		if ((ps->ps_signodefer & mask) == 0)
			ut->uu_sigmask |= mask;
		if ((signum != SIGILL) && (signum != SIGTRAP) && (ps->ps_sigreset & mask)) {
			if ((signum != SIGCONT) && (sigprop[signum] & SA_IGNORE))
				p->p_sigignore |= mask;
			ps->ps_sigact[signum] = SIG_DFL;
			ps->ps_siginfo &= ~mask;
			ps->ps_signodefer &= ~mask;
		}

		if (ps->ps_sig != signum) {
			code = 0;
		} else {
			code = ps->ps_code;
			ps->ps_code = 0;
		}
		OSIncrementAtomicLong(&p->p_stats->p_ru.ru_nsignals);
		sendsig(p, catcher, signum, returnmask, code);
	}
	proc_signalend(p, 1);
}