#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_11__   TYPE_4__ ;
typedef  struct TYPE_10__   TYPE_3__ ;
typedef  struct TYPE_9__   TYPE_2__ ;
typedef  struct TYPE_8__   TYPE_1__ ;

/* Type definitions */
typedef  size_t WORD ;
typedef  scalar_t__ ULONG ;
struct TYPE_8__ {size_t NumberOfSections; } ;
struct TYPE_11__ {TYPE_1__ FileHeader; } ;
struct TYPE_9__ {scalar_t__ VirtualSize; } ;
struct TYPE_10__ {scalar_t__ PointerToRawData; scalar_t__ SizeOfRawData; scalar_t__ VirtualAddress; TYPE_2__ Misc; } ;
typedef  TYPE_3__ IMAGE_SECTION_HEADER ;
typedef  TYPE_4__ IMAGE_NT_HEADERS ;

/* Variables and functions */
 TYPE_3__* IMAGE_FIRST_SECTION (TYPE_4__*) ; 

ULONG RvaToOffset(IMAGE_NT_HEADERS *NT, ULONG Rva)
{
 ULONG Offset = Rva, Limit;
 IMAGE_SECTION_HEADER *Img;
 WORD i;

 Img = IMAGE_FIRST_SECTION(NT);

 if (Rva < Img->PointerToRawData)
  return Rva;

 for (i = 0; i < NT->FileHeader.NumberOfSections; i++)
 {
  if (Img[i].SizeOfRawData)
   Limit = Img[i].SizeOfRawData;
  else
   Limit = Img[i].Misc.VirtualSize;

  if (Rva >= Img[i].VirtualAddress &&
   Rva < (Img[i].VirtualAddress + Limit))
  {
   if (Img[i].PointerToRawData != 0)
   {
    Offset -= Img[i].VirtualAddress;
    Offset += Img[i].PointerToRawData;
   }

   return Offset;
  }
 }

 return 0;
}