#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int /*<<< orphan*/  alnum_nop ;
typedef  int UINT ;
typedef  char* UCHAR ;

/* Variables and functions */
 char** malloc (int) ; 
 int /*<<< orphan*/  memset (char**,int /*<<< orphan*/ ,int) ; 
 int rand () ; 
 int /*<<< orphan*/  strcat (char**,...) ; 

UCHAR *get_nop_slide(UINT size, UINT slide)
{   //simple alnum nop slide generator
    UINT i, x, append_dec_eax = 0;
    UCHAR alnum_nop[][3] = {
        "AI", //inc ecx;dec ecx // (alnum_nop[0])
        "BJ", //inc edx;dec edx // (alnum_nop[1])
        "CK", //inc ebx;dec ebx // (alnum_nop[2])
        "EM", //inc ebp;dec ebp // (alnum_nop[3])
        "FN", //inc esi;dec esi // (alnum_nop[4])
        "GO", //inc edi;dec edi // (alnum_nop[5])                                [we don't care about eax value before the imul]
        "HG", //dec eax;inc edi // (alnum_nop[6]) --- not allowed in nop_slide_2 [instruction as it overwrites eax with result ]
        "HO", //dec eax;dec edi // (alnum_nop[7]) --- not allowed in nop_slide_2 [and we don't care about edi value at all.    ]

        "DL", //inc esp;dec esp // (alnum_nop[8]) --- [todo: need to preserve stack state] >--. //we can freely inc/dec esp for now
//      "PX", //push eax;pop eax// (alnum_nop[9]) --- [todo: need to preserve stack state] >--| //but we need to take it into account
//      "QY", //push ecx;pop ecx// (alnum_nop[10]) ---[todo: need to preserve stack state] >--| //once we start pushing/poping to/from
//      "RZ", //push edx;pop edx// (alnum_nop[11]) ---[todo: need to preserve stack state] >--' //the stack.
//                                                                                            |
//TODO:   <-----------------------------------------------------------------------------------'
//    push eax   push eax   push eax   push ecx  push edx   
//    pop eax    push ecx   push ecx   dec esp   pop edx    
//    push ecx   pop ecx    push edx   inc esp   push ecx   
//    pop ecx    pop eax    inc esp    pop ecx   pop ecx    
//    push edx   push edx   dec esp    push eax  push eax   
//    pop edx    pop edx    pop edx    inc esp   pop eax    
//                          pop ecx    dec esp   .          
//                          pop eax    pop eax   .          
//                                     push edx  .          
//                                     pop edx   etc...     
    };
    UCHAR *nop_slide;
    nop_slide = malloc(size);
    memset(nop_slide, 0, size);
    if(size%2)
    {
        append_dec_eax = 1;
        size--;
    }
    for(i=0; i<(size/2); i++) {
        do 
            x = rand()%(sizeof(alnum_nop)/3);
        while
            ((slide==2)&&(x==6||x==7));
        strcat(nop_slide, alnum_nop[x]);
    }
    if(append_dec_eax)
    {
        strcat(nop_slide, slide==1?"H":rand()%2?"G":"O"); //dec eax or inc/dec edi - depends on which nop slide
    }
    return nop_slide;
}