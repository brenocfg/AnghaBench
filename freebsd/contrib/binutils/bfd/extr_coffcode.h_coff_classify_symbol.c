#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct internal_syment {int n_sclass; scalar_t__ n_scnum; scalar_t__ n_value; } ;
typedef  enum coff_symbol_classification { ____Placeholder_coff_symbol_classification } coff_symbol_classification ;
typedef  int /*<<< orphan*/  bfd ;
typedef  int /*<<< orphan*/  asection ;

/* Variables and functions */
 int COFF_SYMBOL_COMMON ; 
 int COFF_SYMBOL_GLOBAL ; 
 int COFF_SYMBOL_LOCAL ; 
 int COFF_SYMBOL_PE_SECTION ; 
 int COFF_SYMBOL_UNDEFINED ; 
#define  C_EXT 134 
#define  C_LEAFEXT 133 
#define  C_NT_WEAK 132 
 int C_SECTION ; 
 int C_STAT ; 
#define  C_SYSTEM 131 
#define  C_THUMBEXT 130 
#define  C_THUMBEXTFUNC 129 
#define  C_WEAKEXT 128 
 int /*<<< orphan*/  SYMNMLEN ; 
 int /*<<< orphan*/  _ (char*) ; 
 int /*<<< orphan*/  _bfd_coff_internal_syment_name (int /*<<< orphan*/ *,struct internal_syment*,char*) ; 
 int /*<<< orphan*/  _bfd_error_handler (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  bfd_get_section_name (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/ * coff_section_from_bfd_index (int /*<<< orphan*/ *,scalar_t__) ; 
 scalar_t__ strcmp (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  stub1 (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 

__attribute__((used)) static enum coff_symbol_classification
coff_classify_symbol (bfd *abfd,
		      struct internal_syment *syment)
{
  /* FIXME: This partially duplicates the switch in
     coff_slurp_symbol_table.  */
  switch (syment->n_sclass)
    {
    case C_EXT:
    case C_WEAKEXT:
#ifdef I960
    case C_LEAFEXT:
#endif
#ifdef ARM
    case C_THUMBEXT:
    case C_THUMBEXTFUNC:
#endif
#ifdef C_SYSTEM
    case C_SYSTEM:
#endif
#ifdef COFF_WITH_PE
    case C_NT_WEAK:
#endif
      if (syment->n_scnum == 0)
	{
	  if (syment->n_value == 0)
	    return COFF_SYMBOL_UNDEFINED;
	  else
	    return COFF_SYMBOL_COMMON;
	}
      return COFF_SYMBOL_GLOBAL;

    default:
      break;
    }

#ifdef COFF_WITH_PE
  if (syment->n_sclass == C_STAT)
    {
      if (syment->n_scnum == 0)
	/* The Microsoft compiler sometimes generates these if a
	   small static function is inlined every time it is used.
	   The function is discarded, but the symbol table entry
	   remains.  */
	return COFF_SYMBOL_LOCAL;

#ifdef STRICT_PE_FORMAT
      /* This is correct for Microsoft generated objects, but it
         breaks gas generated objects.  */
      if (syment->n_value == 0)
	{
	  asection *sec;
	  char buf[SYMNMLEN + 1];

	  sec = coff_section_from_bfd_index (abfd, syment->n_scnum);
	  if (sec != NULL
	      && (strcmp (bfd_get_section_name (abfd, sec),
			  _bfd_coff_internal_syment_name (abfd, syment, buf))
		  == 0))
	    return COFF_SYMBOL_PE_SECTION;
	}
#endif

      return COFF_SYMBOL_LOCAL;
    }

  if (syment->n_sclass == C_SECTION)
    {
      /* In some cases in a DLL generated by the Microsoft linker, the
         n_value field will contain garbage.  FIXME: This should
         probably be handled by the swapping function instead.  */
      syment->n_value = 0;
      if (syment->n_scnum == 0)
	return COFF_SYMBOL_UNDEFINED;
      return COFF_SYMBOL_PE_SECTION;
    }
#endif /* COFF_WITH_PE */

  /* If it is not a global symbol, we presume it is a local symbol.  */
  if (syment->n_scnum == 0)
    {
      char buf[SYMNMLEN + 1];

      (*_bfd_error_handler)
	(_("warning: %B: local symbol `%s' has no section"),
	 abfd, _bfd_coff_internal_syment_name (abfd, syment, buf));
    }

  return COFF_SYMBOL_LOCAL;
}