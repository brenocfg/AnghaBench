#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_18__   TYPE_6__ ;
typedef  struct TYPE_17__   TYPE_5__ ;
typedef  struct TYPE_16__   TYPE_4__ ;
typedef  struct TYPE_15__   TYPE_3__ ;
typedef  struct TYPE_14__   TYPE_2__ ;
typedef  struct TYPE_13__   TYPE_1__ ;

/* Type definitions */
struct TYPE_17__ {TYPE_4__* symbol; } ;
typedef  TYPE_5__ symbol_node_t ;
struct TYPE_13__ {int* bytes; } ;
struct instruction {int patch_func; int begin; int skip_instr; int skip_patch; TYPE_1__ format; } ;
typedef  struct instruction patch_t ;
struct TYPE_18__ {int begin_addr; int end_addr; } ;
typedef  TYPE_6__ critical_section_t ;
struct TYPE_15__ {TYPE_2__* condinfo; } ;
struct TYPE_16__ {char* name; TYPE_3__ info; } ;
struct TYPE_14__ {int func_num; } ;

/* Variables and functions */
 int /*<<< orphan*/  EX_DATAERR ; 
 TYPE_5__* SLIST_FIRST (int /*<<< orphan*/ *) ; 
 TYPE_5__* SLIST_NEXT (TYPE_5__*,int /*<<< orphan*/ ) ; 
 struct instruction* STAILQ_FIRST (int /*<<< orphan*/ *) ; 
 struct instruction* STAILQ_NEXT (struct instruction*,int /*<<< orphan*/ ) ; 
 TYPE_6__* TAILQ_FIRST (int /*<<< orphan*/ *) ; 
 TYPE_6__* TAILQ_NEXT (TYPE_6__*,int /*<<< orphan*/ ) ; 
 char* appname ; 
 int /*<<< orphan*/  cs_tailq ; 
 int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,...) ; 
 int /*<<< orphan*/  links ; 
 int /*<<< orphan*/  ofile ; 
 char* patch_arg_list ; 
 int /*<<< orphan*/  patch_functions ; 
 int /*<<< orphan*/  patches ; 
 char* prefix ; 
 int /*<<< orphan*/  seq_program ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  stop (char*,int /*<<< orphan*/ ) ; 
 char* versions ; 

__attribute__((used)) static void
output_code()
{
	struct instruction *cur_instr;
	patch_t *cur_patch;
	critical_section_t *cs;
	symbol_node_t *cur_node;
	int instrcount;

	instrcount = 0;
	fprintf(ofile,
"/*\n"
" * DO NOT EDIT - This file is automatically generated\n"
" *		 from the following source files:\n"
" *\n"
"%s */\n", versions);

	fprintf(ofile, "static const uint8_t seqprog[] = {\n");
	for (cur_instr = STAILQ_FIRST(&seq_program);
	     cur_instr != NULL;
	     cur_instr = STAILQ_NEXT(cur_instr, links)) {

		fprintf(ofile, "%s\t0x%02x, 0x%02x, 0x%02x, 0x%02x",
			cur_instr == STAILQ_FIRST(&seq_program) ? "" : ",\n",
#ifdef __LITTLE_ENDIAN
			cur_instr->format.bytes[0],
			cur_instr->format.bytes[1],
			cur_instr->format.bytes[2],
			cur_instr->format.bytes[3]);
#else
			cur_instr->format.bytes[3],
			cur_instr->format.bytes[2],
			cur_instr->format.bytes[1],
			cur_instr->format.bytes[0]);
#endif
		instrcount++;
	}
	fprintf(ofile, "\n};\n\n");

	if (patch_arg_list == NULL)
		stop("Patch argument list not defined",
		     EX_DATAERR);

	/*
	 *  Output patch information.  Patch functions first.
	 */
	fprintf(ofile,
"typedef int %spatch_func_t (%s);\n", prefix, patch_arg_list);

	for (cur_node = SLIST_FIRST(&patch_functions);
	     cur_node != NULL;
	     cur_node = SLIST_NEXT(cur_node,links)) {
		fprintf(ofile,
"static %spatch_func_t %spatch%d_func;\n"
"\n"
"static int\n"
"%spatch%d_func(%s)\n"
"{\n"
"	return (%s);\n"
"}\n\n",
			prefix,
			prefix,
			cur_node->symbol->info.condinfo->func_num,
			prefix,
			cur_node->symbol->info.condinfo->func_num,
			patch_arg_list,
			cur_node->symbol->name);
	}

	fprintf(ofile,
"static const struct patch {\n"
"	%spatch_func_t		*patch_func;\n"
"	uint32_t		 begin		:10,\n"
"				 skip_instr	:10,\n"
"				 skip_patch	:12;\n"
"} patches[] = {\n", prefix);

	for (cur_patch = STAILQ_FIRST(&patches);
	     cur_patch != NULL;
	     cur_patch = STAILQ_NEXT(cur_patch,links)) {
		fprintf(ofile, "%s\t{ %spatch%d_func, %d, %d, %d }",
			cur_patch == STAILQ_FIRST(&patches) ? "" : ",\n",
			prefix,
			cur_patch->patch_func, cur_patch->begin,
			cur_patch->skip_instr, cur_patch->skip_patch);
	}

	fprintf(ofile, "\n};\n\n");

	fprintf(ofile,
"static const struct cs {\n"
"	uint16_t	begin;\n"
"	uint16_t	end;\n"
"} critical_sections[] = {\n");

	for (cs = TAILQ_FIRST(&cs_tailq);
	     cs != NULL;
	     cs = TAILQ_NEXT(cs, links)) {
		fprintf(ofile, "%s\t{ %d, %d }",
			cs == TAILQ_FIRST(&cs_tailq) ? "" : ",\n",
			cs->begin_addr, cs->end_addr);
	}

	fprintf(ofile, "\n};\n\n");

	fprintf(ofile,
	"#define NUM_CRITICAL_SECTIONS ARRAY_SIZE(critical_sections)\n");

	fprintf(stderr, "%s: %d instructions used\n", appname, instrcount);
}