#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_9__   TYPE_2__ ;
typedef  struct TYPE_8__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  u_char ;
typedef  size_t ngx_uint_t ;
struct TYPE_8__ {size_t slab; uintptr_t prev; struct TYPE_8__* next; } ;
typedef  TYPE_1__ ngx_slab_stat_t ;
struct TYPE_9__ {size_t min_size; size_t min_shift; size_t pfree; int log_nomem; char* log_ctx; char zero; TYPE_1__* pages; TYPE_1__* last; int /*<<< orphan*/ * start; int /*<<< orphan*/ * end; TYPE_1__ free; TYPE_1__* stats; } ;
typedef  TYPE_2__ ngx_slab_pool_t ;
typedef  TYPE_1__ ngx_slab_page_t ;
typedef  size_t ngx_int_t ;

/* Variables and functions */
 int /*<<< orphan*/ * ngx_align_ptr (int /*<<< orphan*/ *,int) ; 
 int /*<<< orphan*/  ngx_memzero (TYPE_1__*,size_t) ; 
 int ngx_pagesize ; 
 size_t ngx_pagesize_shift ; 
 int /*<<< orphan*/  ngx_slab_junk (int /*<<< orphan*/ *,size_t) ; 
 TYPE_1__* ngx_slab_slots (TYPE_2__*) ; 

void
ngx_slab_init(ngx_slab_pool_t *pool)
{
    u_char           *p;
    size_t            size;
    ngx_int_t         m;
    ngx_uint_t        i, n, pages;
    ngx_slab_page_t  *slots, *page;

    pool->min_size = (size_t) 1 << pool->min_shift;

    slots = ngx_slab_slots(pool);

    p = (u_char *) slots;
    size = pool->end - p;

    ngx_slab_junk(p, size);

    n = ngx_pagesize_shift - pool->min_shift;

    for (i = 0; i < n; i++) {
        /* only "next" is used in list head */
        slots[i].slab = 0;
        slots[i].next = &slots[i];
        slots[i].prev = 0;
    }

    p += n * sizeof(ngx_slab_page_t);

    pool->stats = (ngx_slab_stat_t *) p;
    ngx_memzero(pool->stats, n * sizeof(ngx_slab_stat_t));

    p += n * sizeof(ngx_slab_stat_t);

    size -= n * (sizeof(ngx_slab_page_t) + sizeof(ngx_slab_stat_t));

    pages = (ngx_uint_t) (size / (ngx_pagesize + sizeof(ngx_slab_page_t)));

    pool->pages = (ngx_slab_page_t *) p;
    ngx_memzero(pool->pages, pages * sizeof(ngx_slab_page_t));

    page = pool->pages;

    /* only "next" is used in list head */
    pool->free.slab = 0;
    pool->free.next = page;
    pool->free.prev = 0;

    page->slab = pages;
    page->next = &pool->free;
    page->prev = (uintptr_t) &pool->free;

    pool->start = ngx_align_ptr(p + pages * sizeof(ngx_slab_page_t),
                                ngx_pagesize);

    m = pages - (pool->end - pool->start) / ngx_pagesize;
    if (m > 0) {
        pages -= m;
        page->slab = pages;
    }

    pool->last = pool->pages + pages;
    pool->pfree = pages;

    pool->log_nomem = 1;
    pool->log_ctx = &pool->zero;
    pool->zero = '\0';
}