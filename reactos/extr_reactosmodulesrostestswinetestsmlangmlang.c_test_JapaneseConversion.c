#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int WCHAR ;
typedef  int INT ;
typedef  int /*<<< orphan*/  HRESULT ;
typedef  int CHAR ;

/* Variables and functions */
 int /*<<< orphan*/  S_FALSE ; 
 int /*<<< orphan*/  S_OK ; 
 scalar_t__ memcmp (int*,int*,int) ; 
 int /*<<< orphan*/  ok (int,char*,int,...) ; 
 int /*<<< orphan*/  pConvertINetMultiByteToUnicode (int /*<<< orphan*/ *,int,int*,int*,int*,int*) ; 
 int /*<<< orphan*/  pConvertINetUnicodeToMultiByte (int /*<<< orphan*/ *,int,int*,int*,int*,int*) ; 
 int /*<<< orphan*/  skip (char*) ; 

__attribute__((used)) static void test_JapaneseConversion(void)
{
    /* Data */
    static WCHAR unc_jp[9][12] = {
  {9,0x31,0x20,0x3042,0x3044,0x3046,0x3048,0x304a,0x000d,0x000a},
  {9,0x31,0x20,0x30a2,0x30a4,0x30a6,0x30a8,0x30aa,0x000d,0x000a},
  {9,0x31,0x20,0xff71,0xff72,0xff73,0xff74,0xff75,0x000d,0x000a},
  {9,0x31,0x20,0x3041,0x3043,0x3045,0x3047,0x3049,0x000d,0x000a},
  {9,0x31,0x20,0x30a1,0x30a3,0x30a5,0x30a7,0x30a9,0x000d,0x000a},
  {9,0x31,0x20,0xff67,0xff68,0xff69,0xff6a,0xff6b,0x000d,0x000a},
  {9,0x31,0x20,0x300c,0x65e5,0x672c,0x8a9e,0x300d,0x000d,0x000a},
  {7,0x31,0x20,0x25c7,0x25c7,0x3012,0x000d,0x000a},
  {11,0x31,0x20,0x203b,0x3010,0x0074,0x0065,0x0073,0x0074,0x3011,0x000d,0x000a}
    };
    static CHAR jis_jp[9][27] = {
  {20,0x31,0x20,0x1b,0x24,0x42,0x24,0x22,0x24,0x24,0x24,0x26,0x24,0x28,
      0x24,0x2a,0x1b,0x28,0x42,0x0d,0x0a},
  {20,0x31,0x20,0x1b,0x24,0x42,0x25,0x22,0x25,0x24,0x25,0x26,0x25,0x28,
      0x25,0x2a,0x1b,0x28,0x42,0x0d,0x0a},
  {20,0x31,0x20,0x1b,0x24,0x42,0x25,0x22,0x25,0x24,0x25,0x26,0x25,0x28,
      0x25,0x2a,0x1b,0x28,0x42,0x0d,0x0a},
  {20,0x31,0x20,0x1b,0x24,0x42,0x24,0x21,0x24,0x23,0x24,0x25,0x24,0x27,
      0x24,0x29,0x1b,0x28,0x42,0x0d,0x0a},
  {20,0x31,0x20,0x1b,0x24,0x42,0x25,0x21,0x25,0x23,0x25,0x25,0x25,0x27,
      0x25,0x29,0x1b,0x28,0x42,0x0d,0x0a},
  {20,0x31,0x20,0x1b,0x24,0x42,0x25,0x21,0x25,0x23,0x25,0x25,0x25,0x27,
      0x25,0x29,0x1b,0x28,0x42,0x0d,0x0a},
  {20,0x31,0x20,0x1b,0x24,0x42,0x21,0x56,0x46,0x7c,0x4b,0x5c,0x38,0x6c,
      0x21,0x57,0x1b,0x28,0x42,0x0d,0x0a},
  {16,0x31,0x20,0x1b,0x24,0x42,0x21,0x7e,0x21,0x7e,0x22,0x29,0x1b,0x28,
      0x42,0x0d,0x0a},
  {26,0x31,0x20,0x1b,0x24,0x42,0x22,0x28,0x21,0x5a,0x1b,0x28,0x42,0x74,
      0x65,0x73,0x74,0x1b,0x24,0x42,0x21,0x5b,0x1b,0x28,0x42,0x0d,0x0a}
    };
    static CHAR sjis_jp[9][15] = {
  {14,0x31,0x20,0x82,0xa0,0x82,0xa2,0x82,0xa4,0x82,0xa6,0x82,0xa8,0x0d,0x0a},
  {14,0x31,0x20,0x83,0x41,0x83,0x43,0x83,0x45,0x83,0x47,0x83,0x49,0x0d,0x0a},
  {9,0x31,0x20,0xb1,0xb2,0xb3,0xb4,0xb5,0x0d,0x0a},
  {14,0x31,0x20,0x82,0x9f,0x82,0xa1,0x82,0xa3,0x82,0xa5,0x82,0xa7,0x0d,0x0a},
  {14,0x31,0x20,0x83,0x40,0x83,0x42,0x83,0x44,0x83,0x46,0x83,0x48,0x0d,0x0a},
  {9,0x31,0x20,0xa7,0xa8,0xa9,0xaa,0xab,0x0d,0x0a},
  {14,0x31,0x20,0x81,0x75,0x93,0xfa,0x96,0x7b,0x8c,0xea,0x81,0x76,0x0d,0x0a},
  {10,0x31,0x20,0x81,0x9e,0x81,0x9e,0x81,0xa7,0x0d,0x0a},
  {14,0x31,0x20,0x81,0xa6,0x81,0x79,0x74,0x65,0x73,0x74,0x81,0x7a,0x0d,0x0a}
    };
    static CHAR euc_jp[9][15] = {
  {14,0x31,0x20,0xa4,0xa2,0xa4,0xa4,0xa4,0xa6,0xa4,0xa8,0xa4,0xaa,0x0d,0x0a},
  {14,0x31,0x20,0xa5,0xa2,0xa5,0xa4,0xa5,0xa6,0xa5,0xa8,0xa5,0xaa,0x0d,0x0a},
  {14,0x31,0x20,0x8e,0xb1,0x8e,0xb2,0x8e,0xb3,0x8e,0xb4,0x8e,0xb5,0x0d,0x0a},
  {14,0x31,0x20,0xa4,0xa1,0xa4,0xa3,0xa4,0xa5,0xa4,0xa7,0xa4,0xa9,0x0d,0x0a},
  {14,0x31,0x20,0xa5,0xa1,0xa5,0xa3,0xa5,0xa5,0xa5,0xa7,0xa5,0xa9,0x0d,0x0a},
  {14,0x31,0x20,0x8e,0xa7,0x8e,0xa8,0x8e,0xa9,0x8e,0xaa,0x8e,0xab,0x0d,0x0a},
  {14,0x31,0x20,0xa1,0xd6,0xc6,0xfc,0xcb,0xdc,0xb8,0xec,0xa1,0xd7,0x0d,0x0a},
  {10,0x31,0x20,0xa1,0xfe,0xa1,0xfe,0xa2,0xa9,0x0d,0x0a},
  {14,0x31,0x20,0xa2,0xa8,0xa1,0xda,0x74,0x65,0x73,0x74,0xa1,0xdb,0x0d,0x0a}
    };

    INT srcsz, destsz;
    INT i;
    HRESULT hr;
    CHAR output[30];
    WCHAR outputW[30];
    int outlen;

    /* test unc->jis */
    for (i = 0; i < 9; i++)
    {
        int j;
        destsz = 30;
        outlen = jis_jp[i][0];
        srcsz = unc_jp[i][0];
        hr = pConvertINetUnicodeToMultiByte(NULL, 50220, &unc_jp[i][1], &srcsz, output, &destsz);
        if (hr == S_FALSE)
        {
            skip("Code page identifier 50220 is not supported\n");
            break;
        }
        ok(hr == S_OK,"(%i) Expected S_OK, got %08x\n", i, hr);
        ok(destsz == outlen, "(%i) Expected %i, got %i\n",i,outlen,destsz);
        ok(srcsz == unc_jp[i][0],"(%i) Expected %i, got %i\n",i,unc_jp[i][0],srcsz);
        ok(memcmp(output,&jis_jp[i][1],destsz)==0,"(%i) Strings do not match\n",i);

        /* and back */
        srcsz = outlen;
        destsz = 30;
        hr = pConvertINetMultiByteToUnicode(NULL, 50220, output, &srcsz, outputW,&destsz);

        /*
         * JIS does not have hankata so it get automatically converted to
         * zenkata. this means that strings 1 and 2 are identical as well as
         * strings 4 and 5.
         */
        j = i;
        if (i == 2) j = 1;
        if (i == 5) j = 4;

        ok(hr == S_OK,"(%i) Expected S_OK, got %08x\n",i, hr);
        ok(destsz == unc_jp[j][0],"(%i) Expected %i, got %i\n",i,unc_jp[j][0],destsz);
        ok(srcsz == outlen,"(%i) Expected %i, got %i\n",i,outlen,srcsz);
        ok(memcmp(outputW,&unc_jp[j][1],destsz)==0,"(%i) Strings do not match\n",i);
    }

    /* test unc->sjis */
    for (i = 0; i < 9; i++)
    {
        destsz = 30;
        outlen = sjis_jp[i][0];
        srcsz = unc_jp[i][0];

        hr = pConvertINetUnicodeToMultiByte(NULL, 932, &unc_jp[i][1], &srcsz, output, &destsz);
        if (hr == S_FALSE)
        {
            skip("Code page identifier 932 is not supported\n");
            break;
        }
        ok(hr == S_OK,"(%i) Expected S_OK, got %08x\n",i,hr);
        ok(destsz == outlen,"(%i) Expected %i, got %i\n",i,outlen,destsz);
        ok(srcsz == unc_jp[i][0],"(%i) Expected %i, got %i\n",i,unc_jp[i][0],srcsz);
        ok(memcmp(output,&sjis_jp[i][1],outlen)==0,"(%i) Strings do not match\n",i);

        srcsz = outlen;
        destsz = 30;
        hr = pConvertINetMultiByteToUnicode(NULL, 932, output, &srcsz, outputW,&destsz);

        ok(hr == S_OK,"(%i) Expected S_OK, got %08x\n", i, hr);
        ok(destsz == unc_jp[i][0],"(%i) Expected %i, got %i\n",i,unc_jp[i][0],destsz);
        ok(srcsz == outlen,"(%i) Expected %i, got %i\n",i,outlen,srcsz);
        ok(memcmp(outputW,&unc_jp[i][1],destsz)==0,"(%i) Strings do not match\n",i);
    }

    /* test unc->euc */
    for (i = 0; i < 9; i++)
    {
        destsz = 30;
        outlen = euc_jp[i][0];
        srcsz = unc_jp[i][0];

        hr = pConvertINetUnicodeToMultiByte(NULL, 51932, &unc_jp[i][1], &srcsz, output, &destsz);
        if (hr == S_FALSE)
        {
            skip("Code page identifier 51932 is not supported\n");
            break;
        }
        ok(hr == S_OK, "(%i) Expected S_OK, got %08x\n",i,hr);
        ok(destsz == outlen, "(%i) Expected %i, got %i\n",i,outlen,destsz);
        ok(srcsz == unc_jp[i][0],"(%i) Expected %i, got %i\n",i,unc_jp[i][0],destsz);
        ok(memcmp(output,&euc_jp[i][1],outlen)==0,"(%i) Strings do not match\n",i);

        srcsz = outlen;
        destsz = 30;
        hr = pConvertINetMultiByteToUnicode(NULL, 51932, output, &srcsz, outputW,&destsz);

        ok(hr == S_OK,"(%i) Expected S_OK, got %08x\n",i,hr);
        ok(destsz == unc_jp[i][0],"(%i) Expected %i, got %i\n",i,unc_jp[i][0],destsz);
        ok(srcsz == outlen,"(%i) Expected %i, got %i\n",i,outlen,srcsz);
        ok(memcmp(outputW,&unc_jp[i][1],destsz)==0,"(%i) Strings do not match\n",i);
    }

    /* Japanese autodetect */
    i = 0;
    destsz = 30;
    srcsz = jis_jp[i][0];
    hr = pConvertINetMultiByteToUnicode(NULL, 50932, &jis_jp[i][1], &srcsz, outputW, &destsz);
    if (hr == S_FALSE)
    {
        skip("Code page identifier 50932 is not supported\n");
        return;
    }
    ok(hr == S_OK,"(%i) Expected S_OK, got %08x\n",i,hr);
    ok(destsz == unc_jp[i][0],"(%i) Expected %i, got %i\n",i,unc_jp[i][0],destsz);
    ok(srcsz == jis_jp[i][0],"(%i) Expected %i, got %i\n",i,jis_jp[i][0],srcsz);
    ok(memcmp(outputW,&unc_jp[i][1],destsz)==0,"(%i) Strings do not match\n",i);

    i = 1;
    destsz = 30;
    srcsz = sjis_jp[i][0];
    hr = pConvertINetMultiByteToUnicode(NULL, 50932, &sjis_jp[i][1], &srcsz, outputW, &destsz);
    ok(hr == S_OK,"(%i) Expected S_OK, got %08x\n",i,hr);
    ok(destsz == unc_jp[i][0],"(%i) Expected %i, got %i\n",i,unc_jp[i][0],destsz);
    ok(srcsz == sjis_jp[i][0],"(%i) Expected %i, got %i\n",i,sjis_jp[i][0],srcsz);
    ok(memcmp(outputW,&unc_jp[i][1],destsz)==0,"(%i) Strings do not match\n",i);
}